# Быстрая сортировка

### Определение
Быстрая сортировка — это алгоритм сортировки, который основан на стратегии «разделяй и властвуй». Алгоритм разбивает массив на подмассивы и выполняет сортировку. Этот метод эффективен для больших данных. 

### "разделяй и властвуй" 

"Разделяй и властвуй" - это подход к решению задач, который основан на разбиении задачи на уменьшающиеся фрагменты.

Решение задач методом "разделяй и властвуй" состоит из двух шагов: 
1. Определяется базовый случай. Это простейший случай из возможных.
2. Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.

### Принцип работы быстрой сортировки

1. В массиве выбирается элемент, который называется опорным.
2. Находим элементы меньше опорного
3. Находим элементы больше опорного
4. Применяем алгоритм рекурсивно к подмассивам
5. Когда доходим до базового случая алгоритм прекращает работу. 

Разберем подробнее

Есть массив данных. Наша задача применить быструю сортировку.
![Без имени2](https://github.com/user-attachments/assets/40f542d1-d09b-4b39-9a63-a6b4ae1fdcb4)

Выбираем опорный элемент. В качестве этого элемента берем первый элемент массива
![Без имени3](https://github.com/user-attachments/assets/acd8937a-b997-44d4-8a94-2c0d4d3bb7c6)

Отбираем элементы меньше и больше опорного.
![Без имени4](https://github.com/user-attachments/assets/b3e4fe53-1ccf-4f5e-818f-1add740eedda)

Повторяем алгоритм. Получился базовый случай(слева) и пустой массив(справа)
![Без имени5](https://github.com/user-attachments/assets/b830fc01-d22c-4ed5-a6ce-8117f8acd785)


> Базовый случай - это случай, который не требует работы алгоритма, так как уже представляет собой решение. Например для массива, базовым случаем является массив, который состоит из одного элемента.


### Практика

На листинге ниже представлен массив данных, который содержит информацию о учащихся. Массив содержит: имя, класс и оценку. Задача - отсортировать массив по оценкам учеников.
```
students_list = [  
    {"name": "Alice", "class": "A", "grade": 88},  
    {"name": "Bob", "class": "B", "grade": 77},  
    {"name": "Charlie", "class": "B", "grade": 85},  
    {"name": "David", "class": "B", "grade": 91},  
    {"name": "Eva", "class": "C", "grade": 21},  
    {"name": "Frank", "class": "A", "grade": 48},  
    {"name": "Grace", "class": "C", "grade": 52},  
    {"name": "Hannah", "class": "C", "grade": 33},  
    {"name": "Ian", "class": "A", "grade": 79},  
    {"name": "Jane", "class": "A", "grade": 21}  
]
```

Алгоритм  занимает меньше места, чем массив данных.
```
def quicksort(array):  
    if len(array) < 2:  
        return array  
    else:  
        pivot = array[0]  
        left_subarray = [i for i in array[1:] if i["grade"] <= pivot["grade"]]  
        right_subarray = [j for j in array[1:] if j["grade"] > pivot["grade"]]  
  
    return quicksort(left_subarray) + [pivot] + quicksort(right_subarray)  
  
print(quicksort(students_list))
```
Разберем подробнее. 
```
if len(array) < 2:  
        return array 
```
Это условие возвращает базовый случай, если он определен. То есть, если наш массив  меньше двух элементов, то массив состоит из одного элемента и не нуждается в сортировке. 
```
else:  
        pivot = array[0]  
        left_subarray = [i for i in array[1:] if i["grade"] <= pivot["grade"]]  
        right_subarray = [j for j in array[1:] if j["grade"] > pivot["grade"]]  
  
```
Главный блок, который выполняет всю логику. 
Выбираем опорный элемент - `pivot`, берем первый элемент массива. Подразделяем на два подмассива - `left_subarray` и `right_subarray`, которые являются списковым включением. 

Логика в списковом включении. 
Цикл итерирует наш массив данных без первого элемента, так как мы его определили опорным. Далее идет условие, которое сравнивает оценку взятого n элемента с опорным элементом. Если n элемент меньше, то определяется в `left_subarray`
подмассив, если больше, то в `right_subarray` подмассив. 

### Заключение

Быстрая сортировка - это алгоритм, который требуется изучить, когда мы говорим о алгоритмах.
